<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Remote Classroom â€” Low-BW Prototype</title>
  <style>
    :root{
      --bg:#0f1720; --panel:#0b1220; --card:#0f1728; --accent:#06b6d4; --muted:#9ca3af;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:Inter, system-ui, Arial, sans-serif; background:var(--bg); color:#e6eef6;
      -webkit-font-smoothing:antialiased;
    }
    header{background:linear-gradient(90deg,#071022,#0b1220); padding:14px 18px; text-align:center; font-weight:700}
    .app{max-width:1100px;margin:18px auto;padding:12px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:12px; padding:14px}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    input{padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
    button{padding:10px 12px;border-radius:8px;border:0;background:var(--accent);color:#022;cursor:pointer;font-weight:600}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    button.warn{background:#ef4444;color:#fff}
    #videos{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;margin-top:14px}
    .tile{background:#000;border-radius:10px;overflow:hidden;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative}
    .tile video{width:100%;height:100%;object-fit:cover;display:block}
    .label{position:absolute;left:8px;bottom:8px;background:rgba(0,0,0,0.6);padding:6px 8px;border-radius:6px;font-size:13px;color:#fff}
    #bitrate{position:fixed;right:14px;bottom:14px;background:rgba(0,0,0,0.6);padding:8px 10px;border-radius:8px;font-family:monospace}
    @media (max-width:640px){ .row{flex-direction:column;align-items:stretch} }
  </style>
</head>
<body>
  <header>ðŸŽ“ Remote Classroom â€” Low-BW Prototype</header>

  <main class="app">
    <div class="card">
      <div class="row" style="align-items:center;margin-bottom:12px">
        <input id="roomId" placeholder="Room ID (alphanumeric)" />
        <input id="roomPass" type="password" placeholder="Room password" />
        <button id="createBtn">Create Room</button>
        <button id="joinBtn">Join Room</button>
        <button id="leaveBtn" class="warn" disabled>Leave Room</button>

        <div style="flex:1"></div>

        <button id="toggleAudioBtn" class="ghost" disabled>Mute Audio</button>
        <button id="toggleVideoBtn" class="ghost" disabled>Disable Video</button>
      </div>

      <div id="status" style="color:var(--muted);margin-bottom:10px">Status: idle</div>

      <div id="videos">
        <!-- local + remote tiles inserted here -->
      </div>
    </div>
  </main>

  <div id="bitrate">Bitrate: 0 kbps</div>

<script>
(() => {
  // --- CONFIG ---
  const DEFAULT_ICE_SERVERS = [
    { urls: 'stun:stun.l.google.com:19302' }
  ];
  const MAX_VIDEO_BITRATE = 400 * 1000; // 400 kbps
  const clientId = Math.random().toString(36).slice(2,9);

  // --- STATE ---
  let ws = null;
  let sendQueue = [];
  let roomId = null;
  let roomPass = null;
  let localStream = null;
  const peers = new Map(); // peerId -> { pc, videoEl, pendingCandidates:[], last }
  let monitorTimer = null;
  let lastOutboundBytes = 0;
  let lastInboundBytes = 0;
  let lastMonitorTs = 0;
  let iceServers = DEFAULT_ICE_SERVERS.slice();

  // --- UI refs ---
  const roomInput = document.getElementById('roomId');
  const passInput = document.getElementById('roomPass');
  const createBtn = document.getElementById('createBtn');
  const joinBtn = document.getElementById('joinBtn');
  const leaveBtn = document.getElementById('leaveBtn');
  const toggleAudioBtn = document.getElementById('toggleAudioBtn');
  const toggleVideoBtn = document.getElementById('toggleVideoBtn');
  const statusEl = document.getElementById('status');
  const videosEl = document.getElementById('videos');
  const bitrateEl = document.getElementById('bitrate');

  function setStatus(s){ statusEl.textContent = 'Status: ' + s; }

  // --- util: ensure WS open and buffer sends ---
  const SIGNALING_URL = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host;
  function ensureWS(){
    if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;
    ws = new WebSocket(SIGNALING_URL);
    ws.onopen = () => {
      while(sendQueue.length) ws.send(JSON.stringify(sendQueue.shift()));
    };
    ws.onmessage = ev => handleSignalMessage(JSON.parse(ev.data));
    ws.onclose = () => console.log('WS closed');
    ws.onerror = e => console.error('WS error', e);
  }
  function safeSend(obj){
    if (!ws || ws.readyState !== WebSocket.OPEN) {
      sendQueue.push(obj);
      ensureWS();
    } else {
      ws.send(JSON.stringify(obj));
    }
  }

  // --- try to fetch TURN servers from /turn (optional) ---
  async function fetchTurnServers(){
    try {
      const resp = await fetch('/turn');
      if (!resp.ok) return;
      const data = await resp.json();
      const turnServers = [];
      if (Array.isArray(data.urls)) {
        turnServers.push({ urls: data.urls, username: data.username, credential: data.credential });
      }
      if (turnServers.length) {
        iceServers = turnServers.concat(DEFAULT_ICE_SERVERS);
        console.log('Using TURN servers from /turn');
      }
    } catch(e){
      console.log('No /turn endpoint or fetch failed, using STUN-only');
    }
  }

  // --- local media ---
  async function startLocalMedia(){
    if (localStream) return;
    try {
      localStream = await navigator.mediaDevices.getUserMedia({
        audio: { echoCancellation:true, noiseSuppression:true },
        video: { width:640, height:360, frameRate:15 }
      });
      createOrUpdateLocalTile();
      toggleAudioBtn.disabled = false;
      toggleVideoBtn.disabled = false;
    } catch(e){
      alert('Camera/mic error: ' + (e.message || e));
      throw e;
    }
  }

  function createOrUpdateLocalTile(){
    let tile = document.getElementById('tile-local');
    if (!tile) {
      tile = document.createElement('div'); tile.className = 'tile'; tile.id = 'tile-local';
      const v = document.createElement('video'); v.id = 'video-local'; v.autoplay = true; v.muted = true; v.playsInline = true;
      const lbl = document.createElement('div'); lbl.className = 'label'; lbl.innerText = 'You';
      tile.appendChild(v); tile.appendChild(lbl);
      videosEl.prepend(tile);
    }
    document.getElementById('video-local').srcObject = localStream;
  }

  // --- create peer object ---
  function createPeerObject(peerId) {
    if (peers.has(peerId)) return peers.get(peerId);
    const pc = new RTCPeerConnection({ iceServers });

    // attach local tracks (if available)
    if (localStream) {
      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
    }

    // create remote tile
    const tile = document.createElement('div'); tile.className = 'tile'; tile.id = 'tile-' + peerId;
    const vid = document.createElement('video'); vid.id = 'video-' + peerId; vid.autoplay = true; vid.playsInline = true;
    const lbl = document.createElement('div'); lbl.className = 'label'; lbl.innerText = 'Peer: ' + peerId;
    tile.appendChild(vid); tile.appendChild(lbl);
    videosEl.appendChild(tile);

    const pendingCandidates = [];
    const last = { lastBytes: 0, lastTs: 0 };

    pc.ontrack = (ev) => { vid.srcObject = ev.streams[0]; };

    pc.onicecandidate = (ev) => {
      if (ev.candidate) {
        safeSend({ type:'signal', roomId, target: peerId, from: clientId, payload: { candidate: ev.candidate } });
      }
    };

    pc.onconnectionstatechange = () => {
      console.log('pc state for', peerId, pc.connectionState);
      if (['failed','closed','disconnected'].includes(pc.connectionState)) {
        try{ pc.close(); } catch(e){}
        const el = document.getElementById('tile-' + peerId); if (el) el.remove();
        peers.delete(peerId);
      }
    };

    const obj = { pc, videoEl: vid, pendingCandidates, last };
    peers.set(peerId, obj);
    return obj;
  }

  // deterministic offer rule
  async function maybeStartOffer(peerId) {
    if (clientId <= peerId) return;
    const obj = peers.get(peerId) || createPeerObject(peerId);
    const pc = obj.pc;

    try {
      pc.getSenders().forEach(sender => {
        if (sender.track && sender.track.kind === 'video') {
          const params = sender.getParameters();
          if (!params.encodings || params.encodings.length === 0) params.encodings = [{}];
          params.encodings[0].maxBitrate = MAX_VIDEO_BITRATE;
          sender.setParameters(params).catch(()=>{});
        }
      });
    } catch (e) {}

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    safeSend({ type:'signal', roomId, target: peerId, from: clientId, payload: { sdp: pc.localDescription } });
  }

  // --- signaling handler ---
  async function handleSignalMessage(msg) {
    if (!msg) return;
    if (msg.type === 'error') { alert(msg.message); return; }
    if (msg.type === 'created') { setStatus('Room created: ' + msg.roomId); leaveBtn.disabled = false; return; }
    if (msg.type === 'joined')  { setStatus('Joined room: ' + msg.roomId); leaveBtn.disabled = false; return; }

    if (msg.type === 'peer-joined') {
      const otherId = msg.clientId;
      if (otherId === clientId) return;
      if (!localStream) await startLocalMedia();
      createPeerObject(otherId);
      maybeStartOffer(otherId);
      return;
    }

    if (msg.type === 'signal') {
      const from = msg.from;
      if (!from || from === clientId) return;
      const payload = msg.payload;
      const obj = peers.get(from) || createPeerObject(from);
      const pc = obj.pc;

      if (payload.sdp) {
        const sdpType = payload.sdp.type;
        if (sdpType === 'offer') {
          await pc.setRemoteDescription(new RTCSessionDescription(payload.sdp));
          try {
            pc.getSenders().forEach(sender => {
              if (sender.track && sender.track.kind === 'video') {
                const params = sender.getParameters();
                if (!params.encodings || params.encodings.length === 0) params.encodings = [{}];
                params.encodings[0].maxBitrate = MAX_VIDEO_BITRATE;
                sender.setParameters(params).catch(()=>{});
              }
            });
          } catch(e){}
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          safeSend({ type:'signal', roomId, target: from, from: clientId, payload: { sdp: pc.localDescription } });
          while (obj.pendingCandidates.length) {
            const c = obj.pendingCandidates.shift();
            try { await pc.addIceCandidate(c); } catch(e){}
          }
        } else if (sdpType === 'answer') {
          if (pc.signalingState === 'have-local-offer') {
            await pc.setRemoteDescription(new RTCSessionDescription(payload.sdp));
            while (obj.pendingCandidates.length) {
              const c = obj.pendingCandidates.shift();
              try { await pc.addIceCandidate(c); } catch(e){}
            }
          } else {
            console.warn('Received answer in state', pc.signalingState, ' â€” ignoring.');
          }
        }
      } else if (payload.candidate) {
        if (pc.remoteDescription && pc.remoteDescription.type) {
          try { await pc.addIceCandidate(new RTCIceCandidate(payload.candidate)); } catch(e){}
        } else {
          obj.pendingCandidates.push(new RTCIceCandidate(payload.candidate));
        }
      }
      return;
    }

    if (msg.type === 'peer-left') {
      const id = msg.clientId;
      if (peers.has(id)) {
        const obj = peers.get(id);
        try { obj.pc.close(); } catch(e){}
        const el = document.getElementById('tile-' + id); if (el) el.remove();
        peers.delete(id);
      }
      return;
    }
  }

  // --- UI actions ---
  createBtn.onclick = async () => {
    roomId = roomInput.value.trim(); roomPass = passInput.value.trim();
    if (!roomId || !roomPass) return alert('Enter room id + password');
    fetchTurnServers().finally(async () => {
      await startLocalMedia();
      ensureWS();
      safeSend({ type:'create', roomId, password: roomPass, clientId });
      setStatus('Creating room...');
    });
  };

  joinBtn.onclick = async () => {
    roomId = roomInput.value.trim(); roomPass = passInput.value.trim();
    if (!roomId || !roomPass) return alert('Enter room id + password');
    fetchTurnServers().finally(async () => {
      await startLocalMedia();
      ensureWS();
      safeSend({ type:'join', roomId, password: roomPass, clientId });
      setStatus('Joining room...');
    });
  };

  leaveBtn.onclick = () => {
    if (!roomId) return;
    safeSend({ type:'leave', roomId, clientId });
    cleanup();
    setStatus('Left');
  };

  toggleAudioBtn.onclick = () => {
    if (!localStream) return;
    const t = localStream.getAudioTracks()[0];
    if (!t) return;
    t.enabled = !t.enabled;
    toggleAudioBtn.textContent = t.enabled ? 'Mute Audio' : 'Unmute Audio';
  };
  toggleVideoBtn.onclick = () => {
    if (!localStream) return;
    const t = localStream.getVideoTracks()[0];
    if (!t) return;
    t.enabled = !t.enabled;
    toggleVideoBtn.textContent = t.enabled ? 'Disable Video' : 'Enable Video';
  };

  // --- monitor (upload + download) ---
  function startMonitor() {
    stopMonitor();
    lastOutboundBytes = 0; lastInboundBytes = 0; lastMonitorTs = 0;
    monitorTimer = setInterval(async () => {
      let totalOutbound = 0;
      let totalInbound = 0;
      let latestTs = 0;

      for (const [id, obj] of peers.entries()) {
        try {
          const stats = await obj.pc.getStats();
          stats.forEach(r => {
            // outbound
            if (r.type === 'outbound-rtp' && (r.kind === 'video' || r.mediaType === 'video' || r.isRemote === false)) {
              if (r.bytesSent) totalOutbound += r.bytesSent;
              if (r.timestamp && r.timestamp > latestTs) latestTs = r.timestamp;
            }
            // inbound
            if (r.type === 'inbound-rtp' && (r.kind === 'video' || r.mediaType === 'video' || r.isRemote === false)) {
              if (r.bytesReceived) totalInbound += r.bytesReceived;
              if (r.timestamp && r.timestamp > latestTs) latestTs = r.timestamp;
            }
          });
        } catch(e){}
      }

      const nowTs = latestTs || Date.now();
      if (lastMonitorTs && nowTs && totalOutbound >= lastOutboundBytes && totalInbound >= lastInboundBytes) {
        const seconds = (nowTs - lastMonitorTs) / 1000;
        if (seconds > 0) {
          const uploadKbps = ((totalOutbound - lastOutboundBytes) * 8) / (seconds * 1000);
          const downloadKbps = ((totalInbound - lastInboundBytes) * 8) / (seconds * 1000);
          bitrateEl.textContent = 'Upload: ' + Math.round(uploadKbps) + ' kbps | Download: ' + Math.round(downloadKbps) + ' kbps';
        }
      } else {
        // initial or fallback
        bitrateEl.textContent = 'Upload: 0 kbps | Download: 0 kbps';
      }

      lastOutboundBytes = totalOutbound;
      lastInboundBytes = totalInbound;
      lastMonitorTs = nowTs;
    }, 1000);
  }
  function stopMonitor(){ if (monitorTimer) { clearInterval(monitorTimer); monitorTimer = null; } bitrateEl.textContent = 'Bitrate: 0 kbps'; }

  // start monitor automatically when peers present
  setInterval(()=> { if (!monitorTimer && peers.size > 0) startMonitor(); }, 1000);

  // --- cleanup ---
  function cleanup(){
    stopMonitor();
    for (const [id,obj] of peers.entries()) {
      try{ obj.pc.close(); } catch(e){}
      const el = document.getElementById('tile-' + id); if (el) el.remove();
    }
    peers.clear();
    if (localStream) {
      for (const t of localStream.getTracks()) try{ t.stop(); } catch(e){}
      localStream = null;
      const localTile = document.getElementById('tile-local'); if (localTile) localTile.remove();
    }
    leaveBtn.disabled = true;
    toggleAudioBtn.disabled = true;
    toggleVideoBtn.disabled = true;
    roomId = null; roomPass = null;
  }

  // ensure WS ready on load
  ensureWS();

  // expose for debugging
  window.__rc = { peers, clientId, ensureWS, safeSend, cleanup };

})();
</script>
</body>
</html>
